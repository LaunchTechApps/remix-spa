{"version":3,"file":"entry.client-CX-zzvD3.js","sources":["../../../app/lib/backgroundJobs.ts","../../../node_modules/.pnpm/@remix-run+react@2.15.2_react-dom@18.3.1_react@18.3.1__react@18.3.1_typescript@5.7.2/node_modules/@remix-run/react/dist/esm/errors.js","../../../node_modules/.pnpm/@remix-run+react@2.15.2_react-dom@18.3.1_react@18.3.1__react@18.3.1_typescript@5.7.2/node_modules/@remix-run/react/dist/esm/browser.js","../../../node_modules/.pnpm/react-dom@18.3.1_react@18.3.1/node_modules/react-dom/client.js","../../../app/entry.client.tsx"],"sourcesContent":["import { api } from \"@/api/api\";\nimport { HeadersBuilder, HttpStatus, getErrorResponse } from \"@/api/util\";\nimport log from \"@/lib/logger\";\nimport { sleep } from \"@/lib/util\";\nimport { deleteAllCookies, getSecureCookie, setSecureCookie } from \"@/sessions\";\n\ninterface StartIntervalProps {\n   interval: number;\n   job: () => Promise<void>;\n   timeout: number;\n   runOnStart?: boolean;\n}\nexport const jobInterval = async ({ interval, job, timeout, runOnStart }: StartIntervalProps) => {\n   const jobWrapper = async () => {\n      try {\n         const timeoutPromise = new Promise((_, reject) =>\n            setTimeout(() => reject(new Error(\"Timeout reached!\")), timeout),\n         );\n         await Promise.race([job(), timeoutPromise]);\n      } catch (error) {\n         log.error(\"Error running background jobs:\", error);\n      }\n   };\n\n   if (runOnStart) {\n      sleep.mili(500).then(() => jobWrapper());\n   }\n\n   setInterval(async () => {\n      await jobWrapper();\n   }, interval);\n};\n\nexport const refreshTokenJob = async () => {\n   const accessToken = getSecureCookie(\"access\");\n   const refreshToken = getSecureCookie(\"refresh\");\n\n   if (!accessToken || !refreshToken) return;\n\n   const headers = HeadersBuilder.New()\n      .setAccessToken(accessToken)\n      .setRefreshToken(refreshToken)\n      .build();\n\n   try {\n      await api.isActive({ type: \"refresh\" }, headers);\n\n      const response = await api.newAccessToken(headers);\n\n      const newAccessToken = response.data.accessToken;\n\n      if (newAccessToken) {\n         setSecureCookie(\"access\", newAccessToken);\n      }\n   } catch (error) {\n      log.warn(\"Error occurred during refreshTokenJob:\", error);\n      const errRes = await getErrorResponse(error);\n\n      !errRes ? log.info(\"ERR_RES\", JSON.stringify(errRes)) : log.info(\"ERR_RES FOUND NULLLLL\");\n\n      if (errRes?.isStatus(HttpStatus.Unauthorized)) {\n         log.warn(\"Unauthorized (401) error. Deleting all cookies\");\n         deleteAllCookies();\n      } else {\n         log.error(\"Unexpected error response:\", errRes);\n      }\n   }\n};\n\nexport const accessTokenJob = async () => {\n   const accessToken = getSecureCookie(\"access\");\n   if (!accessToken) return;\n\n   try {\n      const headers = HeadersBuilder.New().setAccessToken(accessToken).build();\n      await api.isActive({ type: \"access\" }, headers);\n   } catch (error) {\n      log.warn(\"Error occurred during accessTokenJob:\", error);\n      const errRes = await getErrorResponse(error);\n\n      !errRes ? log.info(\"ERR_RES\", JSON.stringify(errRes)) : log.info(\"ERR_RES FOUND NULLLLL\");\n\n      if (errRes?.isStatus(HttpStatus.Unauthorized)) {\n         log.warn(\"Unauthorized (401) error. Calling refreshTokenJob\");\n         await refreshTokenJob();\n      } else {\n         log.error(\"Unexpected error response:\", errRes);\n      }\n   }\n};\n","/**\n * @remix-run/react v2.15.2\n *\n * Copyright (c) Remix Software Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */\nimport { UNSAFE_ErrorResponseImpl } from '@remix-run/router';\n\nfunction deserializeErrors(errors) {\n  if (!errors) return null;\n  let entries = Object.entries(errors);\n  let serialized = {};\n  for (let [key, val] of entries) {\n    // Hey you!  If you change this, please change the corresponding logic in\n    // serializeErrors in remix-server-runtime/errors.ts :)\n    if (val && val.__type === \"RouteErrorResponse\") {\n      serialized[key] = new UNSAFE_ErrorResponseImpl(val.status, val.statusText, val.data, val.internal === true);\n    } else if (val && val.__type === \"Error\") {\n      // Attempt to reconstruct the right type of Error (i.e., ReferenceError)\n      if (val.__subType) {\n        let ErrorConstructor = window[val.__subType];\n        if (typeof ErrorConstructor === \"function\") {\n          try {\n            // @ts-expect-error\n            let error = new ErrorConstructor(val.message);\n            error.stack = val.stack;\n            serialized[key] = error;\n          } catch (e) {\n            // no-op - fall through and create a normal Error\n          }\n        }\n      }\n      if (serialized[key] == null) {\n        let error = new Error(val.message);\n        error.stack = val.stack;\n        serialized[key] = error;\n      }\n    } else {\n      serialized[key] = val;\n    }\n  }\n  return serialized;\n}\n\nexport { deserializeErrors };\n","/**\n * @remix-run/react v2.15.2\n *\n * Copyright (c) Remix Software Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */\nimport { createRouter, createBrowserHistory } from '@remix-run/router';\nimport * as React from 'react';\nimport { UNSAFE_mapRouteProperties } from 'react-router';\nimport { matchRoutes, RouterProvider } from 'react-router-dom';\nimport { RemixContext } from './components.js';\nimport { RemixErrorBoundary } from './errorBoundaries.js';\nimport { deserializeErrors } from './errors.js';\nimport { createClientRoutesWithHMRRevalidationOptOut, createClientRoutes, shouldHydrateRouteLoader } from './routes.js';\nimport { decodeViaTurboStream, getSingleFetchDataStrategy } from './single-fetch.js';\nimport invariant from './invariant.js';\nimport { getPatchRoutesOnNavigationFunction, useFogOFWarDiscovery } from './fog-of-war.js';\n\n/* eslint-disable prefer-let/prefer-let */\n\n/* eslint-enable prefer-let/prefer-let */\n\nlet stateDecodingPromise;\nlet router;\nlet routerInitialized = false;\nlet hmrAbortController;\nlet hmrRouterReadyResolve;\n// There's a race condition with HMR where the remix:manifest is signaled before\n// the router is assigned in the RemixBrowser component. This promise gates the\n// HMR handler until the router is ready\nlet hmrRouterReadyPromise = new Promise(resolve => {\n  // body of a promise is executed immediately, so this can be resolved outside\n  // of the promise body\n  hmrRouterReadyResolve = resolve;\n}).catch(() => {\n  // This is a noop catch handler to avoid unhandled promise rejection warnings\n  // in the console. The promise is never rejected.\n  return undefined;\n});\n\n// @ts-expect-error\nif (import.meta && import.meta.hot) {\n  // @ts-expect-error\n  import.meta.hot.accept(\"remix:manifest\", async ({\n    assetsManifest,\n    needsRevalidation\n  }) => {\n    let router = await hmrRouterReadyPromise;\n    // This should never happen, but just in case...\n    if (!router) {\n      console.error(\"Failed to accept HMR update because the router was not ready.\");\n      return;\n    }\n    let routeIds = [...new Set(router.state.matches.map(m => m.route.id).concat(Object.keys(window.__remixRouteModules)))];\n    if (hmrAbortController) {\n      hmrAbortController.abort();\n    }\n    hmrAbortController = new AbortController();\n    let signal = hmrAbortController.signal;\n\n    // Load new route modules that we've seen.\n    let newRouteModules = Object.assign({}, window.__remixRouteModules, Object.fromEntries((await Promise.all(routeIds.map(async id => {\n      var _assetsManifest$hmr, _window$__remixRouteM, _window$__remixRouteM2, _window$__remixRouteM3;\n      if (!assetsManifest.routes[id]) {\n        return null;\n      }\n      let imported = await import(assetsManifest.routes[id].module + `?t=${(_assetsManifest$hmr = assetsManifest.hmr) === null || _assetsManifest$hmr === void 0 ? void 0 : _assetsManifest$hmr.timestamp}`);\n      return [id, {\n        ...imported,\n        // react-refresh takes care of updating these in-place,\n        // if we don't preserve existing values we'll loose state.\n        default: imported.default ? ((_window$__remixRouteM = window.__remixRouteModules[id]) === null || _window$__remixRouteM === void 0 ? void 0 : _window$__remixRouteM.default) ?? imported.default : imported.default,\n        ErrorBoundary: imported.ErrorBoundary ? ((_window$__remixRouteM2 = window.__remixRouteModules[id]) === null || _window$__remixRouteM2 === void 0 ? void 0 : _window$__remixRouteM2.ErrorBoundary) ?? imported.ErrorBoundary : imported.ErrorBoundary,\n        HydrateFallback: imported.HydrateFallback ? ((_window$__remixRouteM3 = window.__remixRouteModules[id]) === null || _window$__remixRouteM3 === void 0 ? void 0 : _window$__remixRouteM3.HydrateFallback) ?? imported.HydrateFallback : imported.HydrateFallback\n      }];\n    }))).filter(Boolean)));\n    Object.assign(window.__remixRouteModules, newRouteModules);\n    // Create new routes\n    let routes = createClientRoutesWithHMRRevalidationOptOut(needsRevalidation, assetsManifest.routes, window.__remixRouteModules, window.__remixContext.state, window.__remixContext.future, window.__remixContext.isSpaMode);\n\n    // This is temporary API and will be more granular before release\n    router._internalSetRoutes(routes);\n\n    // Wait for router to be idle before updating the manifest and route modules\n    // and triggering a react-refresh\n    let unsub = router.subscribe(state => {\n      if (state.revalidation === \"idle\") {\n        unsub();\n        // Abort if a new update comes in while we're waiting for the\n        // router to be idle.\n        if (signal.aborted) return;\n        // Ensure RouterProvider setState has flushed before re-rendering\n        setTimeout(() => {\n          Object.assign(window.__remixManifest, assetsManifest);\n          window.$RefreshRuntime$.performReactRefresh();\n        }, 1);\n      }\n    });\n    window.__remixRevalidation = (window.__remixRevalidation || 0) + 1;\n    router.revalidate();\n  });\n}\n\n/**\n * The entry point for a Remix app when it is rendered in the browser (in\n * `app/entry.client.js`). This component is used by React to hydrate the HTML\n * that was received from the server.\n */\nfunction RemixBrowser(_props) {\n  if (!router) {\n    // When single fetch is enabled, we need to suspend until the initial state\n    // snapshot is decoded into window.__remixContext.state\n    if (window.__remixContext.future.v3_singleFetch) {\n      // Note: `stateDecodingPromise` is not coupled to `router` - we'll reach this\n      // code potentially many times waiting for our state to arrive, but we'll\n      // then only get past here and create the `router` one time\n      if (!stateDecodingPromise) {\n        let stream = window.__remixContext.stream;\n        invariant(stream, \"No stream found for single fetch decoding\");\n        window.__remixContext.stream = undefined;\n        stateDecodingPromise = decodeViaTurboStream(stream, window).then(value => {\n          window.__remixContext.state = value.value;\n          stateDecodingPromise.value = true;\n        }).catch(e => {\n          stateDecodingPromise.error = e;\n        });\n      }\n      if (stateDecodingPromise.error) {\n        throw stateDecodingPromise.error;\n      }\n      if (!stateDecodingPromise.value) {\n        throw stateDecodingPromise;\n      }\n    }\n    let routes = createClientRoutes(window.__remixManifest.routes, window.__remixRouteModules, window.__remixContext.state, window.__remixContext.future, window.__remixContext.isSpaMode);\n    let hydrationData = undefined;\n    if (!window.__remixContext.isSpaMode) {\n      // Create a shallow clone of `loaderData` we can mutate for partial hydration.\n      // When a route exports a `clientLoader` and a `HydrateFallback`, the SSR will\n      // render the fallback so we need the client to do the same for hydration.\n      // The server loader data has already been exposed to these route `clientLoader`'s\n      // in `createClientRoutes` above, so we need to clear out the version we pass to\n      // `createBrowserRouter` so it initializes and runs the client loaders.\n      hydrationData = {\n        ...window.__remixContext.state,\n        loaderData: {\n          ...window.__remixContext.state.loaderData\n        }\n      };\n      let initialMatches = matchRoutes(routes, window.location, window.__remixContext.basename);\n      if (initialMatches) {\n        for (let match of initialMatches) {\n          let routeId = match.route.id;\n          let route = window.__remixRouteModules[routeId];\n          let manifestRoute = window.__remixManifest.routes[routeId];\n          // Clear out the loaderData to avoid rendering the route component when the\n          // route opted into clientLoader hydration and either:\n          // * gave us a HydrateFallback\n          // * or doesn't have a server loader and we have no data to render\n          if (route && shouldHydrateRouteLoader(manifestRoute, route, window.__remixContext.isSpaMode) && (route.HydrateFallback || !manifestRoute.hasLoader)) {\n            hydrationData.loaderData[routeId] = undefined;\n          } else if (manifestRoute && !manifestRoute.hasLoader) {\n            // Since every Remix route gets a `loader` on the client side to load\n            // the route JS module, we need to add a `null` value to `loaderData`\n            // for any routes that don't have server loaders so our partial\n            // hydration logic doesn't kick off the route module loaders during\n            // hydration\n            hydrationData.loaderData[routeId] = null;\n          }\n        }\n      }\n      if (hydrationData && hydrationData.errors) {\n        hydrationData.errors = deserializeErrors(hydrationData.errors);\n      }\n    }\n\n    // We don't use createBrowserRouter here because we need fine-grained control\n    // over initialization to support synchronous `clientLoader` flows.\n    router = createRouter({\n      routes,\n      history: createBrowserHistory(),\n      basename: window.__remixContext.basename,\n      future: {\n        v7_normalizeFormMethod: true,\n        v7_fetcherPersist: window.__remixContext.future.v3_fetcherPersist,\n        v7_partialHydration: true,\n        v7_prependBasename: true,\n        v7_relativeSplatPath: window.__remixContext.future.v3_relativeSplatPath,\n        // Single fetch enables this underlying behavior\n        v7_skipActionErrorRevalidation: window.__remixContext.future.v3_singleFetch === true\n      },\n      hydrationData,\n      mapRouteProperties: UNSAFE_mapRouteProperties,\n      dataStrategy: window.__remixContext.future.v3_singleFetch ? getSingleFetchDataStrategy(window.__remixManifest, window.__remixRouteModules, () => router) : undefined,\n      patchRoutesOnNavigation: getPatchRoutesOnNavigationFunction(window.__remixManifest, window.__remixRouteModules, window.__remixContext.future, window.__remixContext.isSpaMode, window.__remixContext.basename)\n    });\n\n    // We can call initialize() immediately if the router doesn't have any\n    // loaders to run on hydration\n    if (router.state.initialized) {\n      routerInitialized = true;\n      router.initialize();\n    }\n\n    // @ts-ignore\n    router.createRoutesForHMR = createClientRoutesWithHMRRevalidationOptOut;\n    window.__remixRouter = router;\n\n    // Notify that the router is ready for HMR\n    if (hmrRouterReadyResolve) {\n      hmrRouterReadyResolve(router);\n    }\n  }\n\n  // Critical CSS can become stale after code changes, e.g. styles might be\n  // removed from a component, but the styles will still be present in the\n  // server HTML. This allows our HMR logic to clear the critical CSS state.\n\n  let [criticalCss, setCriticalCss] = React.useState(process.env.NODE_ENV === \"development\" ? window.__remixContext.criticalCss : undefined);\n  if (process.env.NODE_ENV === \"development\") {\n    window.__remixClearCriticalCss = () => setCriticalCss(undefined);\n  }\n\n  // This is due to the short circuit return above when the pathname doesn't\n  // match and we force a hard reload.  This is an exceptional scenario in which\n  // we can't hydrate anyway.\n\n  let [location, setLocation] = React.useState(router.state.location);\n  React.useLayoutEffect(() => {\n    // If we had to run clientLoaders on hydration, we delay initialization until\n    // after we've hydrated to avoid hydration issues from synchronous client loaders\n    if (!routerInitialized) {\n      routerInitialized = true;\n      router.initialize();\n    }\n  }, []);\n  React.useLayoutEffect(() => {\n    return router.subscribe(newState => {\n      if (newState.location !== location) {\n        setLocation(newState.location);\n      }\n    });\n  }, [location]);\n  useFogOFWarDiscovery(router, window.__remixManifest, window.__remixRouteModules, window.__remixContext.future, window.__remixContext.isSpaMode);\n\n  // We need to include a wrapper RemixErrorBoundary here in case the root error\n  // boundary also throws and we need to bubble up outside of the router entirely.\n  // Then we need a stateful location here so the user can back-button navigate\n  // out of there\n  return (\n    /*#__PURE__*/\n    // This fragment is important to ensure we match the <RemixServer> JSX\n    // structure so that useId values hydrate correctly\n    React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(RemixContext.Provider, {\n      value: {\n        manifest: window.__remixManifest,\n        routeModules: window.__remixRouteModules,\n        future: window.__remixContext.future,\n        criticalCss,\n        isSpaMode: window.__remixContext.isSpaMode\n      }\n    }, /*#__PURE__*/React.createElement(RemixErrorBoundary, {\n      location: location\n    }, /*#__PURE__*/React.createElement(RouterProvider, {\n      router: router,\n      fallbackElement: null,\n      future: {\n        v7_startTransition: true\n      }\n    }))), window.__remixContext.future.v3_singleFetch ? /*#__PURE__*/React.createElement(React.Fragment, null) : null)\n  );\n}\n\nexport { RemixBrowser };\n","'use strict';\n\nvar m = require('react-dom');\nif (process.env.NODE_ENV === 'production') {\n  exports.createRoot = m.createRoot;\n  exports.hydrateRoot = m.hydrateRoot;\n} else {\n  var i = m.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n  exports.createRoot = function(c, o) {\n    i.usingClientEntryPoint = true;\n    try {\n      return m.createRoot(c, o);\n    } finally {\n      i.usingClientEntryPoint = false;\n    }\n  };\n  exports.hydrateRoot = function(c, h, o) {\n    i.usingClientEntryPoint = true;\n    try {\n      return m.hydrateRoot(c, h, o);\n    } finally {\n      i.usingClientEntryPoint = false;\n    }\n  };\n}\n","/**\n * By default, Remix will handle hydrating your app on the client for you.\n * You are free to delete this file if you'd like to, but if you ever want it revealed again, you can run `npx remix reveal` âœ¨\n * For more information, see https://remix.run/file-conventions/entry.client\n */\n\nimport { accessTokenJob, jobInterval, refreshTokenJob } from \"@/lib/backgroundJobs\";\nimport { milliTo } from \"@/lib/util\";\nimport { RemixBrowser } from \"@remix-run/react\";\nimport { StrictMode, startTransition } from \"react\";\nimport { hydrateRoot } from \"react-dom/client\";\n\nstartTransition(() => {\n   hydrateRoot(\n      document,\n      <StrictMode>\n         <RemixBrowser />\n      </StrictMode>,\n   );\n   jobInterval({\n      interval: milliTo.seconds(15),\n      timeout: 5000,\n      runOnStart: true,\n      job: () => accessTokenJob(),\n   });\n   jobInterval({\n      interval: milliTo.minutes(5),\n      timeout: 5000,\n      runOnStart: true,\n      job: () => refreshTokenJob(),\n   });\n});\n"],"names":["jobInterval","interval","job","timeout","runOnStart","jobWrapper","timeoutPromise","_","reject","error","log","sleep","refreshTokenJob","accessToken","getSecureCookie","refreshToken","headers","HeadersBuilder","api","newAccessToken","setSecureCookie","errRes","getErrorResponse","HttpStatus","deleteAllCookies","accessTokenJob","deserializeErrors","errors","entries","serialized","key","val","UNSAFE_ErrorResponseImpl","ErrorConstructor","stateDecodingPromise","router","routerInitialized","hmrRouterReadyResolve","resolve","RemixBrowser","_props","stream","invariant","decodeViaTurboStream","value","e","routes","createClientRoutes","hydrationData","initialMatches","matchRoutes","match","routeId","route","manifestRoute","shouldHydrateRouteLoader","createRouter","createBrowserHistory","UNSAFE_mapRouteProperties","getSingleFetchDataStrategy","getPatchRoutesOnNavigationFunction","createClientRoutesWithHMRRevalidationOptOut","criticalCss","setCriticalCss","React.useState","location","setLocation","React.useLayoutEffect","newState","useFogOFWarDiscovery","React.createElement","React.Fragment","RemixContext","RemixErrorBoundary","RouterProvider","m","require$$0","hydrateRoot","startTransition","jsx","StrictMode","milliTo"],"mappings":"4VAYO,MAAMA,EAAc,MAAO,CAAE,SAAAC,EAAU,IAAAC,EAAK,QAAAC,EAAS,WAAAC,KAAqC,CAC9F,MAAMC,EAAa,SAAY,CACxB,GAAA,CACD,MAAMC,EAAiB,IAAI,QAAQ,CAACC,EAAGC,IACpC,WAAW,IAAMA,EAAO,IAAI,MAAM,kBAAkB,CAAC,EAAGL,CAAO,CAClE,EACA,MAAM,QAAQ,KAAK,CAACD,EAAI,EAAGI,CAAc,CAAC,QACpCG,EAAO,CACTC,EAAA,MAAM,iCAAkCD,CAAK,CAAA,CAEvD,EAEIL,GACDO,EAAM,KAAK,GAAG,EAAE,KAAK,IAAMN,GAAY,EAG1C,YAAY,SAAY,CACrB,MAAMA,EAAW,GACjBJ,CAAQ,CACd,EAEaW,EAAkB,SAAY,CAClC,MAAAC,EAAcC,EAAgB,QAAQ,EACtCC,EAAeD,EAAgB,SAAS,EAE1C,GAAA,CAACD,GAAe,CAACE,EAAc,OAE7B,MAAAC,EAAUC,EAAe,MAC3B,eAAeJ,CAAW,EAC1B,gBAAgBE,CAAY,EAC5B,MAAM,EAEN,GAAA,CACD,MAAMG,EAAI,SAAS,CAAE,KAAM,SAAA,EAAaF,CAAO,EAIzC,MAAAG,GAFW,MAAMD,EAAI,eAAeF,CAAO,GAEjB,KAAK,YAEjCG,GACDC,EAAgB,SAAUD,CAAc,QAErCV,EAAO,CACTC,EAAA,KAAK,yCAA0CD,CAAK,EAClD,MAAAY,EAAS,MAAMC,EAAiBb,CAAK,EAE1CY,EAAuDX,EAAI,KAAK,uBAAuB,EAA9EA,EAAI,KAAK,UAAW,KAAK,UAAUW,CAAM,CAAC,EAEhDA,GAAA,MAAAA,EAAQ,SAASE,EAAW,eAC7Bb,EAAI,KAAK,gDAAgD,EACxCc,EAAA,GAEbd,EAAA,MAAM,6BAA8BW,CAAM,CACjD,CAEN,EAEaI,EAAiB,SAAY,CACjC,MAAAZ,EAAcC,EAAgB,QAAQ,EAC5C,GAAKD,EAED,GAAA,CACD,MAAMG,EAAUC,EAAe,IAAA,EAAM,eAAeJ,CAAW,EAAE,MAAM,EACvE,MAAMK,EAAI,SAAS,CAAE,KAAM,QAAA,EAAYF,CAAO,QACxCP,EAAO,CACTC,EAAA,KAAK,wCAAyCD,CAAK,EACjD,MAAAY,EAAS,MAAMC,EAAiBb,CAAK,EAE1CY,EAAuDX,EAAI,KAAK,uBAAuB,EAA9EA,EAAI,KAAK,UAAW,KAAK,UAAUW,CAAM,CAAC,EAEhDA,GAAA,MAAAA,EAAQ,SAASE,EAAW,eAC7Bb,EAAI,KAAK,mDAAmD,EAC5D,MAAME,EAAgB,GAElBF,EAAA,MAAM,6BAA8BW,CAAM,CACjD,CAEN,ECzFA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,GAYA,SAASK,EAAkBC,EAAQ,CACjC,GAAI,CAACA,EAAQ,OAAO,KACpB,IAAIC,EAAU,OAAO,QAAQD,CAAM,EAC/BE,EAAa,CAAE,EACnB,OAAS,CAACC,EAAKC,CAAG,IAAKH,EAGrB,GAAIG,GAAOA,EAAI,SAAW,qBACxBF,EAAWC,CAAG,EAAI,IAAIE,EAAyBD,EAAI,OAAQA,EAAI,WAAYA,EAAI,KAAMA,EAAI,WAAa,EAAI,UACjGA,GAAOA,EAAI,SAAW,QAAS,CAExC,GAAIA,EAAI,UAAW,CACjB,IAAIE,EAAmB,OAAOF,EAAI,SAAS,EAC3C,GAAI,OAAOE,GAAqB,WAC9B,GAAI,CAEF,IAAIxB,EAAQ,IAAIwB,EAAiBF,EAAI,OAAO,EAC5CtB,EAAM,MAAQsB,EAAI,MAClBF,EAAWC,CAAG,EAAIrB,CACnB,MAAW,CAEtB,CAEA,CACM,GAAIoB,EAAWC,CAAG,GAAK,KAAM,CAC3B,IAAIrB,EAAQ,IAAI,MAAMsB,EAAI,OAAO,EACjCtB,EAAM,MAAQsB,EAAI,MAClBF,EAAWC,CAAG,EAAIrB,CAC1B,CACA,MACMoB,EAAWC,CAAG,EAAIC,EAGtB,OAAOF,CACT,CC9CA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,GA0BA,IAAIK,EACAC,EACAC,EAAoB,GAEpBC,EAIwB,IAAI,QAAmBC,GAAA,CAGzBD,EAAAC,CAC1B,CAAC,EAAE,MAAM,IAAM,CAIf,CAAC,EAsED,SAASC,EAAaC,EAAQ,CAC5B,GAAI,CAACL,EAAQ,CAGP,GAAA,OAAO,eAAe,OAAO,eAAgB,CAI/C,GAAI,CAACD,EAAsB,CACrB,IAAAO,EAAS,OAAO,eAAe,OACnCC,EAAUD,EAAQ,2CAA2C,EAC7D,OAAO,eAAe,OAAS,OAC/BP,EAAuBS,EAAqBF,EAAQ,MAAM,EAAE,KAAcG,GAAA,CACjE,OAAA,eAAe,MAAQA,EAAM,MACpCV,EAAqB,MAAQ,EAAA,CAC9B,EAAE,MAAWW,GAAA,CACZX,EAAqB,MAAQW,CAAA,CAC9B,CAAA,CAEH,GAAIX,EAAqB,MACvB,MAAMA,EAAqB,MAEzB,GAAA,CAACA,EAAqB,MAClB,MAAAA,CACR,CAEF,IAAIY,EAASC,EAAmB,OAAO,gBAAgB,OAAQ,OAAO,oBAAqB,OAAO,eAAe,MAAO,OAAO,eAAe,OAAQ,OAAO,eAAe,SAAS,EACjLC,EACA,GAAA,CAAC,OAAO,eAAe,UAAW,CAOpBA,EAAA,CACd,GAAG,OAAO,eAAe,MACzB,WAAY,CACV,GAAG,OAAO,eAAe,MAAM,UAAA,CAEnC,EACA,IAAIC,EAAiBC,EAAYJ,EAAQ,OAAO,SAAU,OAAO,eAAe,QAAQ,EACxF,GAAIG,EACF,QAASE,KAASF,EAAgB,CAC5B,IAAAG,EAAUD,EAAM,MAAM,GACtBE,EAAQ,OAAO,oBAAoBD,CAAO,EAC1CE,EAAgB,OAAO,gBAAgB,OAAOF,CAAO,EAKrDC,GAASE,EAAyBD,EAAeD,EAAO,OAAO,eAAe,SAAS,IAAMA,EAAM,iBAAmB,CAACC,EAAc,WACzHN,EAAA,WAAWI,CAAO,EAAI,OAC3BE,GAAiB,CAACA,EAAc,YAM3BN,EAAA,WAAWI,CAAO,EAAI,KACtC,CAGAJ,GAAiBA,EAAc,SACnBA,EAAA,OAAStB,EAAkBsB,EAAc,MAAM,EAC/D,CAKFb,EAASqB,EAAa,CACpB,OAAAV,EACA,QAASW,EAAqB,EAC9B,SAAU,OAAO,eAAe,SAChC,OAAQ,CACN,uBAAwB,GACxB,kBAAmB,OAAO,eAAe,OAAO,kBAChD,oBAAqB,GACrB,mBAAoB,GACpB,qBAAsB,OAAO,eAAe,OAAO,qBAEnD,+BAAgC,OAAO,eAAe,OAAO,iBAAmB,EAClF,EACA,cAAAT,EACA,mBAAoBU,EACpB,aAAc,OAAO,eAAe,OAAO,eAAiBC,EAA2B,OAAO,gBAAiB,OAAO,oBAAqB,IAAMxB,CAAM,EAAI,OAC3J,wBAAyByB,EAAmC,OAAO,gBAAiB,OAAO,oBAAqB,OAAO,eAAe,OAAQ,OAAO,eAAe,UAAW,OAAO,eAAe,QAAQ,CAAA,CAC9M,EAIGzB,EAAO,MAAM,cACKC,EAAA,GACpBD,EAAO,WAAW,GAIpBA,EAAO,mBAAqB0B,EAC5B,OAAO,cAAgB1B,EAGnBE,GACFA,EAAsBF,CAAM,CAC9B,CAOE,GAAA,CAAC2B,EAAaC,CAAc,EAAIC,WAA4F,MAAS,EASrI,CAACC,EAAUC,CAAW,EAAIF,EAAe,SAAA7B,EAAO,MAAM,QAAQ,EAClEgC,OAAAA,EAAAA,gBAAsB,IAAM,CAGrB/B,IACiBA,EAAA,GACpBD,EAAO,WAAW,EAEtB,EAAG,EAAE,EACLgC,EAAAA,gBAAsB,IACbhC,EAAO,UAAsBiC,GAAA,CAC9BA,EAAS,WAAaH,GACxBC,EAAYE,EAAS,QAAQ,CAC/B,CACD,EACA,CAACH,CAAQ,CAAC,EACQI,EAAAlC,EAAQ,OAAO,gBAAiB,OAAO,oBAAqB,OAAO,eAAe,OAAQ,OAAO,eAAe,SAAS,EAU5ImC,EAAAA,cAAoBC,EAAAA,SAAgB,KAAyBD,EAAAA,cAAcE,EAAa,SAAU,CAChG,MAAO,CACL,SAAU,OAAO,gBACjB,aAAc,OAAO,oBACrB,OAAQ,OAAO,eAAe,OAC9B,YAAAV,EACA,UAAW,OAAO,eAAe,SAAA,CACnC,EACoBQ,EAAAA,cAAcG,EAAoB,CACtD,SAAAR,CAAA,EACoBK,EAAAA,cAAcI,EAAgB,CAClD,OAAAvC,EACA,gBAAiB,KACjB,OAAQ,CACN,mBAAoB,EAAA,CACtB,CACD,CAAC,CAAC,EAAG,OAAO,eAAe,OAAO,eAA8BmC,gBAAoBC,EAAAA,SAAgB,IAAI,EAAI,IAAI,CAErH,OCjRII,EAAIC,EAEeD,EAAE,WACvBE,EAAsBF,EAAE,YCO1BG,EAAAA,gBAAgB,IAAM,CACnBD,EACG,SACCE,EAAA,IAAAC,EAAA,WAAA,CACE,SAACD,EAAAA,IAAAxC,EAAA,CAAA,CAAa,CACjB,CAAA,CACH,EACYvC,EAAA,CACT,SAAUiF,EAAQ,QAAQ,EAAE,EAC5B,QAAS,IACT,WAAY,GACZ,IAAK,IAAMxD,EAAe,CAAA,CAC5B,EACWzB,EAAA,CACT,SAAUiF,EAAQ,QAAQ,CAAC,EAC3B,QAAS,IACT,WAAY,GACZ,IAAK,IAAMrE,EAAgB,CAAA,CAC7B,CACJ,CAAC","x_google_ignoreList":[1,2,3]}